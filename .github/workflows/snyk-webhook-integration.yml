name: Snyk Webhook Integration

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:

env:
  SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
  SNYK_ORG_ID: ${{ secrets.SNYK_ORG_ID }}

jobs:
  snyk-webhook-integration:
    runs-on: ubuntu-latest
    name: Snyk Scan with Webhook Integration

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Install Snyk CLI
      run: npm install -g snyk

    - name: Authenticate with Snyk
      run: snyk auth ${{ secrets.SNYK_TOKEN }}

    - name: Snyk Monitor (Open Source - Triggers Webhook)
      id: snyk-monitor
      run: |
        OUTPUT=$(snyk monitor \
          --org=${{ secrets.SNYK_ORG_ID }} \
          --project-name="goof-app-${{ github.event_name == 'pull_request' && 'pr' || 'main' }}" \
          --target-name="github-actions" \
          --target-reference="${{ github.ref_name }}" \
          --severity-threshold=medium 2>&1) || true
        echo "$OUTPUT"

        PROJECT_URL=$(echo "$OUTPUT" | grep -o 'https://app.snyk.io[^ ]*project/[^/ ]*' | head -1 || echo "")
        if [ -n "$PROJECT_URL" ]; then
          PROJECT_ID=$(echo "$PROJECT_URL" | grep -o 'project/[^/]*' | cut -d'/' -f2 || echo "")
          echo "project_id=$PROJECT_ID" >> $GITHUB_OUTPUT
          echo "project_url=$PROJECT_URL" >> $GITHUB_OUTPUT
        fi
      continue-on-error: true

    - name: Snyk Code Test (SAST - Triggers Webhook)
      id: snyk-code
      run: |
        snyk code test \
          --org=${{ secrets.SNYK_ORG_ID }} \
          --report \
          --project-name="goof-app-code-${{ github.event_name == 'pull_request' && 'pr' || 'main' }}" \
          --target-name="github-actions" \
          --target-reference="${{ github.ref_name }}" \
          --severity-threshold=medium > snyk-code-output.txt 2>&1 || true

        PROJECT_URL=$(grep -o 'https://app.snyk.io[^ ]*' snyk-code-output.txt | head -1 || echo "")
        echo "project_url=$PROJECT_URL" >> $GITHUB_OUTPUT
      continue-on-error: true

    - name: Fetch All Issues and Create Work Items
      run: |
        echo "Fetching issues from Snyk projects and creating work items..."

        sudo apt-get update -qq && sudo apt-get install -y jq curl

        ORG_ID="${{ secrets.SNYK_ORG_ID }}"
        SNYK_TOKEN="${{ secrets.SNYK_TOKEN }}"
        API_BASE="https://api.snyk.io/v1"

        # Build list of projects from monitor steps
        PROJECTS_JSON="[]"
        
        # Add project from snyk monitor step if available
        if [ -n "${{ steps.snyk-monitor.outputs.project_id }}" ]; then
          PROJECT_ID="${{ steps.snyk-monitor.outputs.project_id }}"
          PROJECT_URL="${{ steps.snyk-monitor.outputs.project_url }}"
          PROJECT_NAME="goof-app-${{ github.event_name == 'pull_request' && 'pr' || 'main' }}"
          PROJECT_TYPE="npm"
          
          echo "Adding project from monitor step: $PROJECT_NAME ($PROJECT_ID)"
          PROJECTS_JSON=$(echo "$PROJECTS_JSON" | jq --arg id "$PROJECT_ID" --arg name "$PROJECT_NAME" --arg type "$PROJECT_TYPE" '. += [{"id": $id, "name": $name, "type": $type}]')
        fi
        
        # Add project from snyk code test step if available
        if [ -n "${{ steps.snyk-code.outputs.project_url }}" ]; then
          PROJECT_URL="${{ steps.snyk-code.outputs.project_url }}"
          # Extract project ID from URL
          PROJECT_ID=$(echo "$PROJECT_URL" | grep -o 'project/[^/]*' | cut -d'/' -f2 || echo "")
          if [ -n "$PROJECT_ID" ]; then
            PROJECT_NAME="goof-app-code-${{ github.event_name == 'pull_request' && 'pr' || 'main' }}"
            PROJECT_TYPE="sast"
            
            echo "Adding project from code test step: $PROJECT_NAME ($PROJECT_ID)"
            PROJECTS_JSON=$(echo "$PROJECTS_JSON" | jq --arg id "$PROJECT_ID" --arg name "$PROJECT_NAME" --arg type "$PROJECT_TYPE" '. += [{"id": $id, "name": $name, "type": $type}]')
          fi
        fi
        
        # If no projects from monitor steps, try to fetch via API (with fallback)
        if [ "$(echo "$PROJECTS_JSON" | jq 'length')" -eq 0 ]; then
          echo "⚠️  No projects from monitor steps, attempting to fetch via API..."
          
          # Try API authentication
          TEST_RESPONSE=$(curl -s -w "\n%{http_code}" -X GET \
            "${API_BASE}/org/${ORG_ID}/projects" \
            -H "Authorization: token ${SNYK_TOKEN}" \
            -H "Content-Type: application/json")
          
          HTTP_CODE=$(echo "$TEST_RESPONSE" | tail -n1)
          TEST_BODY=$(echo "$TEST_RESPONSE" | sed '$d')
          
          if [ "$HTTP_CODE" -eq 401 ]; then
            echo "⚠️  API authentication failed (401). This is expected if using a personal token without API access."
            echo "   Personal tokens for free/team plans only work for CLI, not REST API."
            echo "   To use REST API, you need a Service Account token or Enterprise plan."
            echo ""
            echo "   Skipping API-based project fetch. Using project IDs from monitor steps only."
          elif [ "$HTTP_CODE" -eq 200 ]; then
            echo "✅ API authentication successful"
            if echo "$TEST_BODY" | jq -e .projects > /dev/null 2>&1; then
              # Get matching projects
              MATCHING_PROJECTS=$(echo "$TEST_BODY" | jq -c '[.projects[]? | select(
                (.name | ascii_downcase | contains("goof")) or 
                (.name | contains("Snyk_Boards_Testing")) or
                (.name | contains("demo"))
              )]')
              
              if [ -n "$MATCHING_PROJECTS" ] && [ "$MATCHING_PROJECTS" != "[]" ] && [ "$MATCHING_PROJECTS" != "null" ]; then
                PROJECTS_JSON="$MATCHING_PROJECTS"
              fi
            fi
          fi
        fi

        PROJECT_COUNT=$(echo "$PROJECTS_JSON" | jq 'length')
        
        if [ "$PROJECT_COUNT" -eq 0 ]; then
          echo "❌ No projects found to process"
          echo "   Make sure snyk monitor and/or snyk code test steps completed successfully"
          exit 1
        fi
        
        echo "Processing $PROJECT_COUNT project(s)"

        # Process each project
        echo "$PROJECTS_JSON" | jq -c '.[]' | while read -r project; do
          PROJECT_ID=$(echo "$project" | jq -r '.id')
          PROJECT_NAME=$(echo "$project" | jq -r '.name')
          PROJECT_TYPE=$(echo "$project" | jq -r '.type')

          echo ""
          echo "=========================================="
          echo "Processing project: $PROJECT_NAME"
          echo "  ID: $PROJECT_ID"
          echo "  Type: $PROJECT_TYPE"
          echo "=========================================="

          # Fetch issues - try API first, fallback to CLI
          USE_CLI=false
          ISSUES_RESPONSE=""
          
          # Try REST API first
          echo "Attempting to fetch issues via REST API..."
          API_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            "${API_BASE}/org/${ORG_ID}/project/${PROJECT_ID}/issues" \
            -H "Authorization: token ${SNYK_TOKEN}" \
            -H "Content-Type: application/json" \
            -d '{
              "filters": {
                "severities": ["critical", "high", "medium"],
                "types": ["vuln", "license", "code"]
              }
            }')
          
          HTTP_CODE=$(echo "$API_RESPONSE" | tail -n1)
          API_BODY=$(echo "$API_RESPONSE" | sed '$d')
          
          if [ "$HTTP_CODE" -eq 401 ]; then
            echo "⚠️  API returned 401 (personal tokens may not have REST API access)"
            echo "   Falling back to CLI method..."
            USE_CLI=true
          elif [ "$HTTP_CODE" -ne 200 ]; then
            echo "⚠️  API returned HTTP $HTTP_CODE"
            echo "   Falling back to CLI method..."
            USE_CLI=true
          else
            ISSUES_RESPONSE="$API_BODY"
            echo "✅ Successfully fetched issues via API"
          fi
          
          # If API failed, use CLI to get issues
          if [ "$USE_CLI" = true ]; then
            echo "Fetching issues via Snyk CLI..."
            
            if [ "$PROJECT_TYPE" = "sast" ] || [ "$PROJECT_TYPE" = "code" ]; then
              # For code/SAST issues, use snyk code test
              CLI_OUTPUT=$(snyk code test --json --org="${ORG_ID}" --severity-threshold=medium 2>&1 || echo "")
            else
              # For dependency issues, use snyk test
              CLI_OUTPUT=$(snyk test --json --org="${ORG_ID}" --severity-threshold=medium 2>&1 || echo "")
            fi
            
            # Convert CLI JSON output to webhook format
            if echo "$CLI_OUTPUT" | jq -e '.vulnerabilities' > /dev/null 2>&1; then
              # Parse snyk test output (dependency vulnerabilities)
              ISSUES_RESPONSE=$(echo "$CLI_OUTPUT" | jq -c '{
                issues: [
                  .vulnerabilities[]? | {
                    id: (.id // .vulnID // "unknown"),
                    title: (.title // .name // "Security Issue"),
                    severity: (.severity // "medium" | ascii_downcase),
                    description: (.description // .summary // "Security vulnerability detected"),
                    type: "vuln",
                    package: (.packageName // .name // "unknown"),
                    packageManager: (.packageManager // "npm"),
                    url: (.url // "https://app.snyk.io"),
                    identifiers: (.identifiers // {})
                  }
                ]
              }')
            elif echo "$CLI_OUTPUT" | jq -e '.runs[0].results[0].ruleId' > /dev/null 2>&1; then
              # Parse snyk code test SARIF output
              ISSUES_RESPONSE=$(echo "$CLI_OUTPUT" | jq -c '{
                issues: [
                  .runs[0].results[]? | {
                    id: (.ruleId // "unknown"),
                    title: (.message.text // .ruleId // "Security Issue"),
                    severity: (.level // "medium" | ascii_downcase | gsub("error"; "high") | gsub("warning"; "medium") | gsub("note"; "low")),
                    description: (.message.text // "Code security issue detected"),
                    type: "code",
                    package: "N/A",
                    packageManager: "N/A",
                    url: "https://app.snyk.io",
                    identifiers: {}
                  }
                ]
              }')
            else
              echo "⚠️  Could not parse CLI output"
              echo "CLI output: $CLI_OUTPUT"
              continue
            fi
            echo "✅ Successfully fetched issues via CLI"
          fi

          echo "Issues Response:"
          echo "$ISSUES_RESPONSE" | jq '.' || echo "$ISSUES_RESPONSE"

          # Check if response has issues
          if ! echo "$ISSUES_RESPONSE" | jq -e '.issues' > /dev/null 2>&1; then
            echo "⚠️  No issues array in response for project $PROJECT_NAME"
            continue
          fi

          ISSUE_COUNT=$(echo "$ISSUES_RESPONSE" | jq -r '.issues | length // 0')
          
          if [ "$ISSUE_COUNT" -eq 0 ]; then
            echo "No issues found for project $PROJECT_NAME"
            continue
          fi

          echo "Found $ISSUE_COUNT issues for $PROJECT_NAME"

          # Format issues to match Snyk webhook format - use temp file to avoid "Argument list too long" error
          TEMP_ISSUES_FILE=$(mktemp)
          echo "$ISSUES_RESPONSE" | jq -c '[.issues[]? | {
            id: (.id // "unknown"),
            issueData: {
              id: (.id // "unknown"),
              title: (.title // "Security Issue"),
              severity: (.severity // "medium" | ascii_downcase),
              description: (.description // "Security vulnerability detected"),
              type: (.type // "vuln"),
              packageName: (.package // .packageName // "unknown"),
              packageManager: (.packageManager // "npm"),
              url: (.url // "https://app.snyk.io"),
              identifiers: (.identifiers // {})
            },
            introducedDate: (now | todateiso8601),
            priority: {
              score: 500,
              factors: []
            }
          }]' > "$TEMP_ISSUES_FILE"

          # Validate formatted issues
          ISSUE_COUNT_IN_FILE=$(jq 'length' "$TEMP_ISSUES_FILE")
          if [ "$ISSUE_COUNT_IN_FILE" -eq 0 ]; then
            echo "⚠️  Failed to format issues for project $PROJECT_NAME (0 issues in file)"
            rm -f "$TEMP_ISSUES_FILE"
            continue
          fi

          # Get org slug from org API if possible, otherwise use default
          ORG_SLUG="integration_testing"
          ORG_NAME="Integration_Testing"
          
          # Build the webhook payload matching Snyk's format - use temp file to avoid argument list issues
          TEMP_PAYLOAD_FILE=$(mktemp)
          jq -n \
            --arg org_id "$ORG_ID" \
            --arg org_name "$ORG_NAME" \
            --arg org_slug "$ORG_SLUG" \
            --arg project_id "$PROJECT_ID" \
            --arg project_name "$PROJECT_NAME" \
            --arg project_type "$PROJECT_TYPE" \
            --slurpfile issues "$TEMP_ISSUES_FILE" \
            '{
              project: {
                id: $project_id,
                name: $project_name,
                browseUrl: "https://app.snyk.io/org/\($org_slug)/project/\($project_id)",
                type: $project_type,
                source: "cli"
              },
              org: {
                id: $org_id,
                name: $org_name,
                slug: $org_slug,
                group: null
              },
              newIssues: $issues[0],
              removedIssues: [],
              timestamp: (now | todateiso8601)
            }' > "$TEMP_PAYLOAD_FILE"
          
          PAYLOAD=$(cat "$TEMP_PAYLOAD_FILE")

          # Validate payload is valid JSON
          if ! jq '.' "$TEMP_PAYLOAD_FILE" > /dev/null 2>&1; then
            echo "❌ ERROR: Invalid JSON payload generated"
            echo "Payload preview:"
            head -c 500 "$TEMP_PAYLOAD_FILE"
            rm -f "$TEMP_ISSUES_FILE" "$TEMP_PAYLOAD_FILE"
            continue
          fi
          
          # Clean up temp files after validation
          rm -f "$TEMP_ISSUES_FILE"

          AZURE_FUNCTION_CODE="${{ secrets.AZURE_FUNCTION_CODE }}"
          if [ -z "$AZURE_FUNCTION_CODE" ]; then
            echo "❌ ERROR: AZURE_FUNCTION_CODE secret is not set"
            continue
          fi

          AZURE_FUNCTION_URL="https://snyk-webhook-68258.azurewebsites.net/api/snykwebhookfunction?code=${AZURE_FUNCTION_CODE}"

          echo "Sending $ISSUE_COUNT issues from $PROJECT_NAME to Azure Function..."
          echo "Payload preview (first 500 chars):"
          head -c 500 "$TEMP_PAYLOAD_FILE"
          echo ""

          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            "$AZURE_FUNCTION_URL" \
            -H "Content-Type: application/json" \
            -H "X-Snyk-Event: project_snapshot" \
            -H "X-Snyk-Timestamp: $(date -u +%Y-%m-%dT%H:%M:%S.000Z)" \
            --data-binary "@$TEMP_PAYLOAD_FILE")
          
          # Clean up payload file after sending
          rm -f "$TEMP_PAYLOAD_FILE"

          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')

          echo "HTTP Status: $HTTP_CODE"
          echo "Response Body: $BODY"

          if [ "$HTTP_CODE" -eq 200 ] || [ "$HTTP_CODE" -eq 201 ] || [ "$HTTP_CODE" -eq 202 ]; then
            echo "✅ Successfully sent $ISSUE_COUNT issues from $PROJECT_NAME to Azure Function"
          else
            echo "❌ HTTP $HTTP_CODE response from Azure Function"
            echo "Response: $BODY"
          fi
        done

        echo ""
        echo "✅ Finished processing all projects"
      continue-on-error: true

    - name: Workflow Summary
      if: always()
      run: |
        echo "## Snyk Scan Complete" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "✅ Snyk monitoring completed" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Webhook Integration" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "All issues (new and existing) have been sent to Azure Function" >> $GITHUB_STEP_SUMMARY
        echo "1. Work items created in Azure DevOps Boards" >> $GITHUB_STEP_SUMMARY
        echo "2. Check: https://dev.azure.com/pr352312/Snyk_Boards_Testing/_boards/board/t/Snyk%20Boards%20Testing/Issues" >> $GITHUB_STEP_SUMMARY
# Trigger test run
